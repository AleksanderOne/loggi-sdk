{"version":3,"sources":["../../src/next/request-context.ts","../../src/types.ts","../../src/transport.ts","../../src/utils/sanitize.ts","../../src/logger.ts","../../src/integrations/console.ts","../../src/integrations/fetch.ts","../../src/config.ts","../../src/next/index.ts","../../src/next/middleware.ts"],"sourcesContent":["import { AsyncLocalStorage } from 'async_hooks';\n\n/**\n * Kontekst requestu - przechowuje requestId przez ca≈Çy cykl ≈ºycia requestu\n */\ninterface RequestContext {\n    requestId: string;\n    startTime: number;\n}\n\n/**\n * AsyncLocalStorage do przechowywania kontekstu requestu\n */\nconst storage = new AsyncLocalStorage<RequestContext>();\n\n/**\n * Generuj unikalny request ID\n */\nexport function generateRequestId(prefix: string = 'req'): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `${prefix}_${timestamp}_${random}`;\n}\n\n/**\n * Pobierz aktualny request ID (lub undefined je≈õli nie ma kontekstu)\n */\nexport function getRequestId(): string | undefined {\n    return storage.getStore()?.requestId;\n}\n\n/**\n * Pobierz czas trwania requestu w ms\n */\nexport function getRequestDuration(): number | undefined {\n    const store = storage.getStore();\n    return store ? Date.now() - store.startTime : undefined;\n}\n\n/**\n * Uruchom funkcjƒô w kontek≈õcie requestu\n */\nexport function runWithRequestId<T>(requestId: string, fn: () => T): T {\n    return storage.run({ requestId, startTime: Date.now() }, fn);\n}\n\n/**\n * Uruchom async funkcjƒô w kontek≈õcie requestu\n */\nexport async function runWithRequestIdAsync<T>(requestId: string, fn: () => Promise<T>): Promise<T> {\n    return storage.run({ requestId, startTime: Date.now() }, fn);\n}\n","/**\n * Poziomy logowania\n * dev - logi developerskie z dodatkowym kontekstem (__file, __memory, __timestamp)\n * log - standardowe logowanie (dawny debug, odpowiednik console.log)\n */\nexport type LogLevel = 'dev' | 'log' | 'info' | 'warn' | 'error' | 'fatal';\n\n/**\n * Kategorie log√≥w - u≈ºywane do grupowania i filtrowania\n * (bazowe + mo≈ºliwo≈õƒá rozszerzenia przez createLogger)\n */\nexport type LogCategory =\n    | 'auth'       // Logowanie, sesje, OAuth\n    | 'api'        // Wywo≈Çania API\n    | 'security'   // Rate limiting, CSRF, walidacja\n    | 'db'         // Operacje bazodanowe\n    | 'middleware' // Middleware logi\n    | 'console'    // Przechwycone z console.*\n    | 'fetch'      // Przechwycone z fetch()\n    | 'error'      // Uncaught errors\n    | 'custom'     // W≈Çasne\n    | 'flow'       // Przep≈Çyw operacji\n    | string;      // Dynamiczne kategorie z API\n\n/**\n * Definicja kategorii z API\n */\nexport interface CategorySchema {\n    key: string;\n    name: string;\n    nameEn: string;\n    icon: string;\n    color: string;\n    ansiColor: string;\n    description: string;\n    examples: string[];\n    isBase: boolean;\n}\n\n/**\n * Schema logowania z API\n */\nexport interface LogSchema {\n    projectId: string;\n    projectName: string;\n    categories: CategorySchema[];\n    version: string;\n    generatedAt: string;\n}\n\n/**\n * Environment aplikacji\n */\nexport type LogEnvironment = 'development' | 'production' | 'staging';\n\n/**\n * ≈πr√≥d≈Ço loga\n */\nexport type LogSource = 'server' | 'client';\n\n/**\n * Pojedynczy wpis loga\n */\nexport interface LogEntry {\n    timestamp: string;\n    level: LogLevel;\n    category: LogCategory;\n    source: LogSource;\n    message: string;\n    data?: Record<string, unknown>;\n    requestId?: string;\n    projectSlug?: string;\n    environment?: LogEnvironment;\n\n    // Kontekst HTTP (opcjonalny)\n    requestUrl?: string;\n    requestMethod?: string;\n    requestStatus?: number;\n    requestDurationMs?: number;\n\n    // Kontekst b≈Çƒôdu (opcjonalny)\n    error?: {\n        name: string;\n        message: string;\n        stack?: string;\n    };\n}\n\n/**\n * Konfiguracja SDK\n */\nexport interface LoggiConfig {\n    /** Klucz API projektu w Loggi-App (opcjonalne - bez klucza dzia≈Ça offline mode) */\n    apiKey?: string;\n\n    /** Endpoint Loggi-App (domy≈õlnie: process.env.LOGGI_ENDPOINT lub http://localhost:3003) */\n    endpoint?: string;\n\n    /** Slug projektu (domy≈õlnie: process.env.LOGGI_PROJECT_SLUG lub auto z package.json) */\n    projectSlug?: string;\n\n    /** Environment (domy≈õlnie: process.env.NODE_ENV) */\n    environment?: LogEnvironment;\n\n    // Auto-capture\n    /** Przechwytywanie console.* (domy≈õlnie: true) */\n    captureConsole?: boolean;\n\n    /** Przechwytywanie fetch() (domy≈õlnie: true) */\n    captureFetch?: boolean;\n\n    /** Przechwytywanie uncaught errors (domy≈õlnie: true) */\n    captureUnhandled?: boolean;\n\n    // Batching\n    /** Wielko≈õƒá batcha (domy≈õlnie: 10) */\n    batchSize?: number;\n\n    /** Timeout batcha w ms (domy≈õlnie: 5000) */\n    batchTimeoutMs?: number;\n\n    // Dev mode\n    /** Tryb debug - wiƒôcej log√≥w (domy≈õlnie: NODE_ENV === 'development') */\n    debug?: boolean;\n\n    /** Wy≈õwietlanie log√≥w w konsoli w dev mode (domy≈õlnie: true) */\n    consoleInDev?: boolean;\n\n    // Filtering\n    /** Minimalny poziom log√≥w do wys≈Çania (domy≈õlnie: 'log' w dev, 'info' w prod) */\n    minLevel?: LogLevel;\n\n    /** Klucze do sanityzacji (domy≈õlnie: ['password', 'token', 'secret', ...]) */\n    sensitiveKeys?: string[];\n\n    /** Mapowanie prefix√≥w console.log na kategorie */\n    prefixMap?: Record<string, LogCategory>;\n\n    // Offline mode (internal - ustawiane automatycznie)\n    /** Tryb offline - logi tylko do konsoli, bez wysy≈Çania do loggi-app */\n    offlineMode?: boolean;\n}\n\n/**\n * Priorytet poziom√≥w logowania\n */\nexport const LEVEL_PRIORITY: Record<LogLevel, number> = {\n    dev: 0,     // Najni≈ºszy - tylko development, z dodatkowym kontekstem\n    log: 1,     // Standardowe logowanie (dawny debug)\n    info: 2,\n    warn: 3,\n    error: 4,\n    fatal: 5,\n};\n\n/**\n * Domy≈õlne mapowanie prefix√≥w na kategorie\n */\nexport const DEFAULT_PREFIX_MAP: Record<string, LogCategory> = {\n    '[CLA AUTH]': 'auth',\n    '[CLA AUTHORIZE]': 'auth',\n    '[CLA TOKEN]': 'auth',\n    '[CLA SECURITY]': 'security',\n    '[CLA API]': 'api',\n    '[CLA DB]': 'db',\n    '[AHA MIDDLEWARE]': 'middleware',\n    '[AHA AUTH]': 'auth',\n    '[AHA PROJECT]': 'api',\n    '[AHA POLICY]': 'security',\n    '[AHA MEMBER]': 'api',\n    '[AHA SESSION]': 'auth',\n    '[FA AUTH]': 'auth',\n    '[FA API]': 'api',\n};\n\n/**\n * Domy≈õlne klucze do sanityzacji\n */\nexport const DEFAULT_SENSITIVE_KEYS = [\n    'password',\n    'token',\n    'secret',\n    'apiKey',\n    'api_key',\n    'authorization',\n    'cookie',\n    'session',\n    'credit_card',\n    'cvv',\n    'ssn',\n];\n","import { LogEntry, LogEnvironment } from './types';\nimport { getConfig, isLoggiInitialized } from './config';\n\n/**\n * Kolejka log√≥w do wys≈Çania\n */\nlet queue: LogEntry[] = [];\n\n/**\n * Timer do automatycznego flush\n */\nlet flushTimer: ReturnType<typeof setTimeout> | null = null;\n\n/**\n * Czy trwa shutdown\n */\nlet isShuttingDown = false;\n\n/**\n * Czy jeste≈õmy w trybie offline (po nieudanych pr√≥bach)\n */\nlet isOffline = false;\n\n/**\n * Licznik kolejnych b≈Çƒôd√≥w po≈ÇƒÖczenia\n */\nlet consecutiveFailures = 0;\n\n/**\n * Max b≈Çƒôd√≥w przed przej≈õciem w tryb offline\n */\nconst MAX_FAILURES_BEFORE_OFFLINE = 3;\n\n/**\n * Konfiguracja retry na starcie\n */\nconst STARTUP_RETRY_CONFIG = {\n    maxRetries: 10,           // Max pr√≥b\n    retryIntervalMs: 60000,   // Interwa≈Ç miƒôdzy pr√≥bami (1 minuta)\n};\n\n/**\n * Czy trwa retry na starcie\n */\nlet isRetrying = false;\n\n/**\n * Licznik pr√≥b retry na starcie\n */\nlet startupRetryCount = 0;\n\n/**\n * Timer do retry\n */\nlet retryTimer: ReturnType<typeof setTimeout> | null = null;\n\n/**\n * Czy po≈ÇƒÖczenie zosta≈Ço nawiƒÖzane (przynajmniej raz)\n */\nlet connectionEstablished = false;\n\n/**\n * Dodaj log do kolejki\n */\nexport function enqueue(entry: LogEntry): void {\n    if (isShuttingDown) return;\n    if (!isLoggiInitialized()) {\n        // SDK nie zainicjalizowane - pomi≈Ñ\n        return;\n    }\n\n    const config = getConfig();\n\n    // Offline mode - nie kolejkuj, logi ju≈º pokazane w konsoli\n    if (config.offlineMode || isOffline) {\n        return;\n    }\n\n    queue.push(entry);\n\n    // Nie flush gdy trwa retry - logi bƒôdƒÖ wys≈Çane po nawiƒÖzaniu po≈ÇƒÖczenia\n    if (isRetrying) {\n        return;\n    }\n\n    scheduleFlush();\n}\n\n/**\n * Zaplanuj flush kolejki\n */\nfunction scheduleFlush(): void {\n    const config = getConfig();\n\n    if (config.offlineMode || isOffline) {\n        return;\n    }\n\n    if (queue.length >= config.batchSize) {\n        // Batch pe≈Çny - wy≈õlij od razu\n        flush();\n    } else if (!flushTimer) {\n        // Zaplanuj flush po timeout\n        flushTimer = setTimeout(() => {\n            flushTimer = null;\n            flush();\n        }, config.batchTimeoutMs);\n    }\n}\n\n/**\n * Wy≈õlij logi do Loggi-App\n */\nexport async function flush(): Promise<void> {\n    if (queue.length === 0) return;\n    if (!isLoggiInitialized()) return;\n\n    const config = getConfig();\n\n    // Offline mode - wyczy≈õƒá kolejkƒô (logi ju≈º by≈Çy w konsoli)\n    if (config.offlineMode || isOffline) {\n        queue = [];\n        return;\n    }\n\n    const batch = queue.splice(0, config.batchSize);\n\n    // Wyczy≈õƒá timer\n    if (flushTimer) {\n        clearTimeout(flushTimer);\n        flushTimer = null;\n    }\n\n    try {\n        // Endpoint bez /api/logs/collect - dodajemy tutaj\n        const endpoint = config.endpoint.includes('/api/logs/collect')\n            ? config.endpoint\n            : config.endpoint + '/api/logs/collect';\n\n        const response = await fetch(endpoint, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-API-Key': config.apiKey,\n            },\n            body: JSON.stringify({\n                logs: batch,\n                projectSlug: config.projectSlug,\n                environment: config.environment as LogEnvironment,\n            }),\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // Reset failure counter na sukces\n        consecutiveFailures = 0;\n\n        if (config.debug) {\n            console.log(`[LOGGI] Sent ${batch.length} logs`);\n        }\n    } catch (error) {\n        consecutiveFailures++;\n\n        // Graceful degradation - po MAX_FAILURES przejd≈∫ w tryb offline\n        if (consecutiveFailures >= MAX_FAILURES_BEFORE_OFFLINE) {\n            isOffline = true;\n            // Wyczy≈õƒá kolejkƒô - logi ju≈º by≈Çy w konsoli (je≈õli debug mode)\n            queue = [];\n\n            if (config.debug) {\n                console.warn(`[LOGGI] Loggi-app unavailable after ${consecutiveFailures} failures. Switching to console-only mode.`);\n            }\n        } else if (config.debug) {\n            console.warn(`[LOGGI] Failed to send logs (attempt ${consecutiveFailures}/${MAX_FAILURES_BEFORE_OFFLINE}):`, error);\n        }\n        // NIE retry - graceful degradation, odpuszczamy logi\n    }\n\n    // Je≈õli zosta≈Ço co≈õ w kolejce i nie jeste≈õmy offline, zaplanuj kolejny flush\n    if (queue.length > 0 && !isOffline) {\n        scheduleFlush();\n    }\n}\n\n/**\n * Sprawd≈∫ czy transport jest w trybie offline\n */\nexport function isTransportOffline(): boolean {\n    return isOffline;\n}\n\n/**\n * Resetuj tryb offline (np. po ponownym po≈ÇƒÖczeniu)\n */\nexport function resetOfflineMode(): void {\n    isOffline = false;\n    consecutiveFailures = 0;\n    connectionEstablished = false;\n    startupRetryCount = 0;\n    isRetrying = false;\n    if (retryTimer) {\n        clearTimeout(retryTimer);\n        retryTimer = null;\n    }\n}\n\n/**\n * Sprawd≈∫ dostƒôpno≈õƒá serwera loggi-app\n */\nasync function checkServerAvailability(): Promise<boolean> {\n    if (!isLoggiInitialized()) return false;\n\n    const config = getConfig();\n    if (config.offlineMode) return false;\n\n    try {\n        const healthEndpoint = config.endpoint + '/api/health';\n        const response = await fetch(healthEndpoint, {\n            method: 'GET',\n            signal: AbortSignal.timeout(5000), // 5s timeout\n        });\n        return response.ok;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Uruchom retry loop - pr√≥buje po≈ÇƒÖczyƒá siƒô z serwerem co minutƒô, max 10 razy\n */\nasync function startRetryLoop(): Promise<void> {\n    if (isRetrying || connectionEstablished || isShuttingDown) return;\n    if (!isLoggiInitialized()) return;\n\n    const config = getConfig();\n    if (config.offlineMode) return;\n\n    isRetrying = true;\n    startupRetryCount = 0;\n\n    const attemptConnection = async () => {\n        if (isShuttingDown || connectionEstablished) {\n            isRetrying = false;\n            return;\n        }\n\n        startupRetryCount++;\n\n        if (config.debug) {\n            console.log(`[LOGGI] Pr√≥ba po≈ÇƒÖczenia z serwerem log√≥w (${startupRetryCount}/${STARTUP_RETRY_CONFIG.maxRetries})...`);\n        }\n\n        const available = await checkServerAvailability();\n\n        if (available) {\n            connectionEstablished = true;\n            isRetrying = false;\n            isOffline = false;\n            consecutiveFailures = 0;\n\n            if (config.debug) {\n                console.log('[LOGGI] ‚úÖ Po≈ÇƒÖczono z serwerem log√≥w');\n            }\n\n            // Wy≈õlij zaleg≈Çe logi\n            if (queue.length > 0) {\n                scheduleFlush();\n            }\n            return;\n        }\n\n        if (startupRetryCount >= STARTUP_RETRY_CONFIG.maxRetries) {\n            // Wyczerpano pr√≥by - przejd≈∫ w tryb offline na sta≈Çe\n            isRetrying = false;\n            isOffline = true;\n            queue = []; // Wyczy≈õƒá kolejkƒô\n\n            console.warn(\n                `[LOGGI] ‚ùå Nie uda≈Ço siƒô po≈ÇƒÖczyƒá z serwerem log√≥w po ${STARTUP_RETRY_CONFIG.maxRetries} pr√≥bach. ` +\n                `Przechodzƒô w tryb offline (tylko konsola).`\n            );\n            return;\n        }\n\n        // Zaplanuj nastƒôpnƒÖ pr√≥bƒô\n        if (config.debug) {\n            console.log(`[LOGGI] Serwer niedostƒôpny. Nastƒôpna pr√≥ba za ${STARTUP_RETRY_CONFIG.retryIntervalMs / 1000}s...`);\n        }\n\n        retryTimer = setTimeout(attemptConnection, STARTUP_RETRY_CONFIG.retryIntervalMs);\n    };\n\n    // Pierwsza pr√≥ba natychmiast\n    await attemptConnection();\n}\n\n/**\n * Inicjalizuj transport - wywo≈Çaj po initLoggi()\n */\nexport async function initTransport(): Promise<void> {\n    if (!isLoggiInitialized()) return;\n\n    const config = getConfig();\n    if (config.offlineMode) return;\n\n    // Sprawd≈∫ czy serwer jest dostƒôpny\n    const available = await checkServerAvailability();\n\n    if (available) {\n        connectionEstablished = true;\n        if (config.debug) {\n            console.log('[LOGGI] ‚úÖ Serwer log√≥w dostƒôpny');\n        }\n    } else {\n        // Serwer niedostƒôpny - uruchom retry loop w tle\n        console.warn('[LOGGI] ‚ö†Ô∏è Serwer log√≥w niedostƒôpny. Uruchamiam retry w tle...');\n        startRetryLoop();\n    }\n}\n\n/**\n * Graceful shutdown - wy≈õlij pozosta≈Çe logi przed zamkniƒôciem\n */\nasync function gracefulShutdown(signal: string): Promise<void> {\n    if (isShuttingDown) return;\n    if (!isLoggiInitialized()) return; // SDK nie zainicjalizowane - nic do zrobienia\n    isShuttingDown = true;\n\n    const config = getConfig();\n    if (config.debug) {\n        console.log(`[LOGGI] Received ${signal}, flushing remaining logs...`);\n    }\n\n    // Wyczy≈õƒá timery\n    if (flushTimer) {\n        clearTimeout(flushTimer);\n        flushTimer = null;\n    }\n    if (retryTimer) {\n        clearTimeout(retryTimer);\n        retryTimer = null;\n    }\n    isRetrying = false;\n\n    // Wy≈õlij wszystko co zosta≈Ço (je≈õli nie jeste≈õmy offline i mamy po≈ÇƒÖczenie)\n    if (!config.offlineMode && !isOffline && connectionEstablished && queue.length > 0) {\n        await flush();\n    }\n\n    if (config.debug) {\n        console.log('[LOGGI] Shutdown complete');\n    }\n}\n\n// Rejestruj handlery shutdown (tylko w Node.js, nie w Edge Runtime)\n// Edge Runtime ma `process` ale nie ma `process.on`\nif (typeof process !== 'undefined' && typeof process.on === 'function') {\n    process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n    process.on('beforeExit', () => gracefulShutdown('beforeExit'));\n}\n","/**\n * Rekurencyjnie sanityzuje obiekt, ukrywajƒÖc wra≈ºliwe dane\n */\nexport function sanitize(\n    data: Record<string, unknown> | undefined,\n    sensitiveKeys: string[]\n): Record<string, unknown> | undefined {\n    if (!data) return undefined;\n\n    const result: Record<string, unknown> = {};\n    const lowercaseKeys = sensitiveKeys.map(k => k.toLowerCase());\n\n    for (const [key, value] of Object.entries(data)) {\n        const keyLower = key.toLowerCase();\n\n        // Sprawd≈∫ czy klucz jest wra≈ºliwy\n        if (lowercaseKeys.some(sk => keyLower.includes(sk))) {\n            result[key] = '[REDACTED]';\n        } else if (value && typeof value === 'object' && !Array.isArray(value)) {\n            // Rekurencyjnie sanityzuj zagnie≈ºd≈ºone obiekty\n            result[key] = sanitize(value as Record<string, unknown>, sensitiveKeys);\n        } else if (Array.isArray(value)) {\n            // Sanityzuj elementy tablicy\n            result[key] = value.map(item =>\n                item && typeof item === 'object'\n                    ? sanitize(item as Record<string, unknown>, sensitiveKeys)\n                    : item\n            );\n        } else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Sanityzuje string message - ukrywa tokeny i has≈Ça\n */\nexport function sanitizeMessage(message: string): string {\n    // Ukryj tokeny JWT\n    let sanitized = message.replace(\n        /eyJ[A-Za-z0-9-_]+\\.eyJ[A-Za-z0-9-_]+\\.[A-Za-z0-9-_.+/=]*/g,\n        '[JWT_TOKEN]'\n    );\n\n    // Ukryj Bearer tokens\n    sanitized = sanitized.replace(\n        /Bearer\\s+[A-Za-z0-9-_.]+/gi,\n        'Bearer [TOKEN]'\n    );\n\n    // Ukryj has≈Ça w formatach key=value\n    sanitized = sanitized.replace(\n        /(password|secret|token|apikey|api_key)[\\s]*[=:]\\s*[\"']?[^\"'\\s,}]+[\"']?/gi,\n        '$1=[REDACTED]'\n    );\n\n    return sanitized;\n}\n","import { LogLevel, LogCategory, LogEntry, LogSchema, CategorySchema, LEVEL_PRIORITY } from './types';\nimport { getConfig, isLoggiInitialized } from './config';\nimport { enqueue } from './transport';\nimport { sanitize, sanitizeMessage } from './utils/sanitize';\nimport { getRequestId } from './next/request-context';\n\n/**\n * Zapisz oryginalne console.log przed przechwyceniem\n * (u≈ºywane przez printToConsole ≈ºeby uniknƒÖƒá pƒôtli)\n */\nconst _originalConsoleLog = console.log.bind(console);\n\n/**\n * Formatowanie log√≥w do konsoli\n */\nconst LEVEL_COLORS: Record<LogLevel, string> = {\n    dev: '\\x1b[35m',    // magenta - wyra≈∫ny dla dev\n    log: '\\x1b[90m',    // gray (dawny debug)\n    info: '\\x1b[36m',   // cyan\n    warn: '\\x1b[33m',   // yellow\n    error: '\\x1b[31m',  // red\n    fatal: '\\x1b[35m',  // magenta\n};\n\nconst LEVEL_EMOJI: Record<LogLevel, string> = {\n    dev: 'üõ†Ô∏è',\n    log: 'üîç',\n    info: 'üìã',\n    warn: '‚ö†Ô∏è',\n    error: '‚ùå',\n    fatal: 'üíÄ',\n};\n\n// Bazowe emoji dla kategorii (fallback)\nconst CATEGORY_EMOJI: Record<string, string> = {\n    auth: 'üîê',\n    api: 'üì°',\n    security: 'üõ°Ô∏è',\n    db: 'üíæ',\n    middleware: 'üîÑ',\n    console: 'üìù',\n    fetch: 'üåê',\n    error: '‚ùå',\n    custom: 'üìã',\n    flow: 'üîÑ',\n};\n\nconst RESET = '\\x1b[0m';\nconst BOLD = '\\x1b[1m';\nconst DIM = '\\x1b[2m';\n\n// Flaga do wy≈õwietlania ostrze≈ºenia o deprecated debug() tylko raz\nlet _debugDeprecationWarningShown = false;\n\nfunction warnDebugDeprecated(): void {\n    if (!_debugDeprecationWarningShown) {\n        console.warn('[LOGGI] ‚ö†Ô∏è Metoda .debug() jest deprecated. U≈ºyj .log() zamiast tego.');\n        _debugDeprecationWarningShown = true;\n    }\n}\n\n/**\n * Cache schematu kategorii\n */\nlet _schemaCache: LogSchema | null = null;\nlet _categoryMap: Map<string, CategorySchema> = new Map();\n\n/**\n * Wy≈õwietl log w konsoli (tylko w dev mode)\n * Format: TIMESTAMP LEVEL_ICON LEVEL CATEGORY_ICON CATEGORY MESSAGE\n */\nfunction printToConsole(entry: LogEntry): void {\n    const levelColor = LEVEL_COLORS[entry.level];\n    const levelEmoji = LEVEL_EMOJI[entry.level];\n    const levelLabel = entry.level.toUpperCase().padEnd(5);\n\n    // Pobierz info o kategorii z cache lub fallback\n    const catInfo = _categoryMap.get(entry.category);\n    const catEmoji = catInfo?.icon || CATEGORY_EMOJI[entry.category] || 'üìã';\n    const catColor = catInfo?.ansiColor || '\\x1b[37m';\n    const catName = catInfo?.name || entry.category;\n\n    // Timestamp: HH:MM:SS.mmm\n    const now = new Date(entry.timestamp);\n    const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;\n\n    // Format: TIMESTAMP LEVEL_ICON LEVEL CATEGORY_ICON CATEGORY(key) MESSAGE\n    const categoryLabel = `${catName}(${entry.category})`.padEnd(20);\n\n    const prefix = `${DIM}${timestamp}${RESET} ${levelEmoji} ${levelColor}${levelLabel}${RESET} ${catEmoji} ${catColor}${BOLD}${categoryLabel}${RESET}`;\n\n    if (entry.data && Object.keys(entry.data).length > 0) {\n        _originalConsoleLog(prefix, entry.message);\n        // Formatuj dane\n        const dataStr = Object.entries(entry.data)\n            .filter(([, v]) => v !== undefined && v !== null && v !== '')\n            .map(([k, v]) => {\n                const formatted = typeof v === 'object' ? JSON.stringify(v) : String(v);\n                return `${DIM}${k}${RESET}=${formatted.length > 60 ? formatted.slice(0, 57) + '...' : formatted}`;\n            })\n            .join(` ${DIM}‚îÇ${RESET} `);\n        if (dataStr) {\n            _originalConsoleLog(`    ${DIM}‚îî‚îÄ${RESET} ${dataStr}`);\n        }\n    } else {\n        _originalConsoleLog(prefix, entry.message);\n    }\n}\n\n/**\n * G≈Ç√≥wna funkcja logowania\n */\nfunction log(\n    level: LogLevel,\n    category: LogCategory,\n    message: string,\n    data?: Record<string, unknown>\n): void {\n    if (!isLoggiInitialized()) {\n        // SDK nie zainicjalizowane - po prostu wy≈õwietl w konsoli\n        console.log(`[${level.toUpperCase()}] [${category}] ${message}`, data || '');\n        return;\n    }\n\n    const config = getConfig();\n\n    // Sprawd≈∫ minLevel\n    if (LEVEL_PRIORITY[level] < LEVEL_PRIORITY[config.minLevel]) {\n        return;\n    }\n\n    // Sanityzacja\n    const sanitizedData = sanitize(data, config.sensitiveKeys);\n    const sanitizedMessage = sanitizeMessage(message);\n\n    const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        category,\n        source: 'server',\n        message: sanitizedMessage,\n        data: sanitizedData,\n        requestId: getRequestId(),\n        projectSlug: config.projectSlug,\n        environment: config.environment,\n    };\n\n    // Dev mode - te≈º do konsoli\n    if (config.debug && config.consoleInDev) {\n        printToConsole(entry);\n    }\n\n    // Wy≈õlij do Loggi-App\n    enqueue(entry);\n}\n\n/**\n * Tworzy logger dla konkretnej kategorii\n */\nfunction createCategoryLogger(category: LogCategory) {\n    const logMethod = (message: string, data?: Record<string, unknown>) => log('log', category, message, data);\n    return {\n        dev: (message: string, data?: Record<string, unknown>) => log('dev', category, message, data),\n        log: logMethod,\n        info: (message: string, data?: Record<string, unknown>) => log('info', category, message, data),\n        warn: (message: string, data?: Record<string, unknown>) => log('warn', category, message, data),\n        error: (message: string, data?: Record<string, unknown>) => log('error', category, message, data),\n        fatal: (message: string, data?: Record<string, unknown>) => log('fatal', category, message, data),\n        /** @deprecated U≈ºyj .log() */\n        debug: (message: string, data?: Record<string, unknown>) => {\n            warnDebugDeprecated();\n            logMethod(message, data);\n        },\n    };\n}\n\nconst logMethodCustom = (message: string, data?: Record<string, unknown>) => log('log', 'custom', message, data);\n\n/**\n * G≈Ç√≥wny obiekt loggera\n */\nexport const logger = {\n    // Podstawowe metody (u≈ºywajƒÖ kategorii 'custom')\n    dev: (message: string, data?: Record<string, unknown>) => log('dev', 'custom', message, data),\n    log: logMethodCustom,\n    info: (message: string, data?: Record<string, unknown>) => log('info', 'custom', message, data),\n    warn: (message: string, data?: Record<string, unknown>) => log('warn', 'custom', message, data),\n    error: (message: string, data?: Record<string, unknown>) => log('error', 'custom', message, data),\n    fatal: (message: string, data?: Record<string, unknown>) => log('fatal', 'custom', message, data),\n    /** @deprecated U≈ºyj .log() */\n    debug: (message: string, data?: Record<string, unknown>) => {\n        warnDebugDeprecated();\n        logMethodCustom(message, data);\n    },\n\n    // Loggery dla konkretnych kategorii\n    auth: createCategoryLogger('auth'),\n    api: createCategoryLogger('api'),\n    security: createCategoryLogger('security'),\n    db: createCategoryLogger('db'),\n    middleware: createCategoryLogger('middleware'),\n};\n\n/**\n * Eksport wewnƒôtrznej funkcji log (do u≈ºytku przez integracje)\n */\nexport { log as _internalLog };\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// DYNAMICZNE LOGGERY\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n/**\n * Typ dla dynamicznego loggera kategorii\n */\nexport type CategoryLogger = {\n    dev: (message: string, data?: Record<string, unknown>) => void;\n    log: (message: string, data?: Record<string, unknown>) => void;\n    info: (message: string, data?: Record<string, unknown>) => void;\n    warn: (message: string, data?: Record<string, unknown>) => void;\n    error: (message: string, data?: Record<string, unknown>) => void;\n    fatal: (message: string, data?: Record<string, unknown>) => void;\n    /** @deprecated U≈ºyj .log() */\n    debug: (message: string, data?: Record<string, unknown>) => void;\n};\n\n/**\n * Typ zwracany przez createLogger\n */\nexport type DynamicLogger<T extends string> = {\n    [K in T]: CategoryLogger;\n} & {\n    // Podstawowe metody (domy≈õlna kategoria 'custom')\n    dev: (message: string, data?: Record<string, unknown>) => void;\n    log: (message: string, data?: Record<string, unknown>) => void;\n    info: (message: string, data?: Record<string, unknown>) => void;\n    warn: (message: string, data?: Record<string, unknown>) => void;\n    error: (message: string, data?: Record<string, unknown>) => void;\n    fatal: (message: string, data?: Record<string, unknown>) => void;\n    /** @deprecated U≈ºyj .log() */\n    debug: (message: string, data?: Record<string, unknown>) => void;\n    // Metadane\n    _schema: LogSchema | null;\n    _categories: string[];\n};\n\n/**\n * Pobierz schemat kategorii z API\n */\nexport async function fetchSchema(): Promise<LogSchema | null> {\n    if (_schemaCache) return _schemaCache;\n\n    if (!isLoggiInitialized()) {\n        return null;\n    }\n\n    const config = getConfig();\n    const schemaUrl = config.endpoint.replace('/api/logs/collect', `/api/log-schema/${config.projectSlug}`);\n\n    try {\n        const response = await fetch(schemaUrl, {\n            headers: {\n                'X-API-Key': config.apiKey,\n            },\n        });\n\n        if (!response.ok) {\n            if (config.debug) {\n                console.warn(`[LOGGI] Failed to fetch schema: ${response.status}`);\n            }\n            return null;\n        }\n\n        const schema = await response.json() as LogSchema;\n        _schemaCache = schema;\n\n        // Buduj mapƒô kategorii\n        for (const cat of schema.categories) {\n            _categoryMap.set(cat.key, cat);\n        }\n\n        if (config.debug) {\n            console.log(`[LOGGI] Schema loaded: ${schema.categories.length} categories`);\n        }\n\n        return schema;\n    } catch (err) {\n        if (config.debug) {\n            console.warn('[LOGGI] Failed to fetch schema:', err);\n        }\n        return null;\n    }\n}\n\n/**\n * Tworzy dynamiczny logger na podstawie schematu z API\n *\n * @example\n * // W instrumentation.ts lub na poczƒÖtku aplikacji:\n * const logger = await createLogger();\n *\n * // U≈ºycie:\n * logger.auth.info('User logged in', { userId: '123' });\n * logger.payment.error('Transaction failed', { orderId: 'abc' });\n *\n * // Lub z okre≈õlonymi kategoriami (type-safe):\n * const logger = await createLogger<'auth' | 'payment' | 'learning'>();\n * logger.learning.info('Card reviewed');\n */\nexport async function createLogger<T extends string = string>(): Promise<DynamicLogger<T>> {\n    const schema = await fetchSchema();\n\n    // Kategorie ze schematu lub fallback do bazowych\n    const categoryKeys = schema?.categories.map(c => c.key) || ['auth', 'api', 'security', 'db', 'flow', 'custom'];\n\n    const logMethodCustom = (message: string, data?: Record<string, unknown>) => log('log', 'custom', message, data);\n\n    // Buduj obiekt loggera\n    const dynamicLogger: Record<string, unknown> = {\n        // Podstawowe metody\n        dev: (message: string, data?: Record<string, unknown>) => log('dev', 'custom', message, data),\n        log: logMethodCustom,\n        info: (message: string, data?: Record<string, unknown>) => log('info', 'custom', message, data),\n        warn: (message: string, data?: Record<string, unknown>) => log('warn', 'custom', message, data),\n        error: (message: string, data?: Record<string, unknown>) => log('error', 'custom', message, data),\n        fatal: (message: string, data?: Record<string, unknown>) => log('fatal', 'custom', message, data),\n        debug: (message: string, data?: Record<string, unknown>) => {\n            warnDebugDeprecated();\n            logMethodCustom(message, data);\n        },\n\n        // Metadane\n        _schema: schema,\n        _categories: categoryKeys,\n    };\n\n    // Dodaj loggery dla ka≈ºdej kategorii\n    for (const key of categoryKeys) {\n        const logMethodCat = (message: string, data?: Record<string, unknown>) => log('log', key as LogCategory, message, data);\n        dynamicLogger[key] = {\n            dev: (message: string, data?: Record<string, unknown>) => log('dev', key as LogCategory, message, data),\n            log: logMethodCat,\n            info: (message: string, data?: Record<string, unknown>) => log('info', key as LogCategory, message, data),\n            warn: (message: string, data?: Record<string, unknown>) => log('warn', key as LogCategory, message, data),\n            error: (message: string, data?: Record<string, unknown>) => log('error', key as LogCategory, message, data),\n            fatal: (message: string, data?: Record<string, unknown>) => log('fatal', key as LogCategory, message, data),\n            debug: (message: string, data?: Record<string, unknown>) => {\n                warnDebugDeprecated();\n                logMethodCat(message, data);\n            },\n        };\n    }\n\n    return dynamicLogger as DynamicLogger<T>;\n}\n\n/**\n * Wersja synchroniczna createLogger (bez pobierania schematu)\n * U≈ºywa cache je≈õli schemat zosta≈Ç ju≈º pobrany\n */\nexport function createLoggerSync<T extends string = string>(): DynamicLogger<T> {\n    const categoryKeys = _schemaCache?.categories.map(c => c.key) || ['auth', 'api', 'security', 'db', 'flow', 'custom'];\n\n    const logMethodCustom = (message: string, data?: Record<string, unknown>) => log('log', 'custom', message, data);\n\n    const dynamicLogger: Record<string, unknown> = {\n        dev: (message: string, data?: Record<string, unknown>) => log('dev', 'custom', message, data),\n        log: logMethodCustom,\n        info: (message: string, data?: Record<string, unknown>) => log('info', 'custom', message, data),\n        warn: (message: string, data?: Record<string, unknown>) => log('warn', 'custom', message, data),\n        error: (message: string, data?: Record<string, unknown>) => log('error', 'custom', message, data),\n        fatal: (message: string, data?: Record<string, unknown>) => log('fatal', 'custom', message, data),\n        debug: (message: string, data?: Record<string, unknown>) => {\n            warnDebugDeprecated();\n            logMethodCustom(message, data);\n        },\n        _schema: _schemaCache,\n        _categories: categoryKeys,\n    };\n\n    for (const key of categoryKeys) {\n        const logMethodCat = (message: string, data?: Record<string, unknown>) => log('log', key as LogCategory, message, data);\n        dynamicLogger[key] = {\n            dev: (message: string, data?: Record<string, unknown>) => log('dev', key as LogCategory, message, data),\n            log: logMethodCat,\n            info: (message: string, data?: Record<string, unknown>) => log('info', key as LogCategory, message, data),\n            warn: (message: string, data?: Record<string, unknown>) => log('warn', key as LogCategory, message, data),\n            error: (message: string, data?: Record<string, unknown>) => log('error', key as LogCategory, message, data),\n            fatal: (message: string, data?: Record<string, unknown>) => log('fatal', key as LogCategory, message, data),\n            debug: (message: string, data?: Record<string, unknown>) => {\n                warnDebugDeprecated();\n                logMethodCat(message, data);\n            },\n        };\n    }\n\n    return dynamicLogger as DynamicLogger<T>;\n}\n","import { LogLevel, LogCategory } from '../types';\nimport { getConfig, isLoggiInitialized } from '../config';\nimport { _internalLog } from '../logger';\n\n/**\n * Oryginalne metody console\n */\nlet originalConsole: {\n    log: typeof console.log;\n    info: typeof console.info;\n    warn: typeof console.warn;\n    error: typeof console.error;\n    debug: typeof console.debug;\n} | null = null;\n\n/**\n * Czy console jest ju≈º przechwycone\n */\nlet isCaptured = false;\n\n/**\n * Mapowanie metod console na poziomy log√≥w\n * console.log -> 'log' (dawny debug)\n * console.debug -> 'log' (mapowany tak samo jak console.log)\n */\nconst METHOD_TO_LEVEL: Record<string, LogLevel> = {\n    log: 'log',     // console.log -> poziom 'log'\n    info: 'info',\n    warn: 'warn',\n    error: 'error',\n    debug: 'log',   // console.debug -> poziom 'log' (nie 'dev')\n};\n\n/**\n * Formatuj argumenty console do stringa\n */\nfunction formatArgs(args: unknown[]): string {\n    return args.map(arg => {\n        if (typeof arg === 'string') return arg;\n        if (typeof arg === 'object') {\n            try {\n                return JSON.stringify(arg);\n            } catch {\n                return String(arg);\n            }\n        }\n        return String(arg);\n    }).join(' ');\n}\n\n/**\n * WyciƒÖgnij kategoriƒô z prefiksu wiadomo≈õci\n */\nfunction extractCategoryFromPrefix(message: string): LogCategory {\n    if (!isLoggiInitialized()) return 'console';\n\n    const config = getConfig();\n    for (const [prefix, category] of Object.entries(config.prefixMap)) {\n        if (message.startsWith(prefix)) {\n            return category;\n        }\n    }\n    return 'console';\n}\n\n/**\n * Usu≈Ñ prefiks z wiadomo≈õci (opcjonalne - zachowujemy dla czytelno≈õci)\n */\nfunction removePrefixFromMessage(message: string): string {\n    if (!isLoggiInitialized()) return message;\n\n    const config = getConfig();\n    for (const prefix of Object.keys(config.prefixMap)) {\n        if (message.startsWith(prefix)) {\n            return message.slice(prefix.length).trim();\n        }\n    }\n    return message;\n}\n\n/**\n * Przechwytuj console.*\n */\nexport function captureConsole(): void {\n    if (isCaptured) return;\n    isCaptured = true;\n\n    // Zapisz oryginalne metody\n    originalConsole = {\n        log: console.log,\n        info: console.info,\n        warn: console.warn,\n        error: console.error,\n        debug: console.debug,\n    };\n\n    const methods = ['log', 'info', 'warn', 'error', 'debug'] as const;\n\n    for (const method of methods) {\n        const original = originalConsole[method];\n\n        (console as unknown as Record<string, unknown>)[method] = (...args: unknown[]) => {\n            // Wywo≈Çaj oryginalnƒÖ metodƒô w dev mode\n            if (isLoggiInitialized()) {\n                const config = getConfig();\n                if (config.debug && config.consoleInDev) {\n                    original.apply(console, args);\n                }\n            } else {\n                // SDK nie zainicjalizowane - normalne wywo≈Çanie\n                original.apply(console, args);\n            }\n\n            // Formatuj wiadomo≈õƒá\n            const message = formatArgs(args);\n\n            // Pomi≈Ñ logi SDK (anty-pƒôtla)\n            if (message.includes('[LOGGI]')) return;\n\n            // WyciƒÖgnij kategoriƒô i poziom\n            const category = extractCategoryFromPrefix(message);\n            const level = METHOD_TO_LEVEL[method];\n\n            // WyciƒÖgnij dane z ostatniego argumentu (je≈õli to obiekt)\n            let data: Record<string, unknown> | undefined;\n            const lastArg = args[args.length - 1];\n            if (args.length > 1 && typeof lastArg === 'object' && lastArg !== null && !Array.isArray(lastArg)) {\n                data = lastArg as Record<string, unknown>;\n            }\n\n            // Wy≈õlij do Loggi\n            _internalLog(level, category, message, data);\n        };\n    }\n}\n\n/**\n * Przywr√≥ƒá oryginalne console (do test√≥w)\n */\nexport function restoreConsole(): void {\n    if (!isCaptured || !originalConsole) return;\n\n    console.log = originalConsole.log;\n    console.info = originalConsole.info;\n    console.warn = originalConsole.warn;\n    console.error = originalConsole.error;\n    console.debug = originalConsole.debug;\n\n    originalConsole = null;\n    isCaptured = false;\n}\n\n/**\n * Surowe console - loguje bez przechwytywania przez SDK.\n * U≈ºyj gdy masz w≈Çasny logger kt√≥ry formatuje output i nie chcesz duplikacji.\n */\nexport const rawConsole = {\n    log: (...args: unknown[]) => {\n        (originalConsole?.log ?? console.log).apply(console, args);\n    },\n    info: (...args: unknown[]) => {\n        (originalConsole?.info ?? console.info).apply(console, args);\n    },\n    warn: (...args: unknown[]) => {\n        (originalConsole?.warn ?? console.warn).apply(console, args);\n    },\n    error: (...args: unknown[]) => {\n        (originalConsole?.error ?? console.error).apply(console, args);\n    },\n    debug: (...args: unknown[]) => {\n        (originalConsole?.debug ?? console.debug).apply(console, args);\n    },\n};\n","import { getConfig, isLoggiInitialized } from '../config';\nimport { _internalLog } from '../logger';\nimport { getRequestId } from '../next/request-context';\n\n/**\n * Oryginalny fetch\n */\nlet originalFetch: typeof fetch | null = null;\n\n/**\n * Czy fetch jest ju≈º przechwycony\n */\nlet isCaptured = false;\n\n// Typy dla fetch - kompatybilne z Node.js i przeglƒÖdarkƒÖ\ntype FetchInput = Parameters<typeof fetch>[0];\ntype FetchInit = Parameters<typeof fetch>[1];\n\n/**\n * WyciƒÖgnij URL z input fetch\n */\nfunction extractUrl(input: FetchInput): string {\n    if (typeof input === 'string') return input;\n    if (input instanceof URL) return input.toString();\n    if (typeof input === 'object' && 'url' in input) return (input as { url: string }).url;\n    return String(input);\n}\n\n/**\n * Przechwytuj fetch()\n */\nexport function captureFetch(): void {\n    if (isCaptured) return;\n    if (typeof globalThis.fetch !== 'function') return;\n\n    isCaptured = true;\n    originalFetch = globalThis.fetch;\n\n    globalThis.fetch = async (input: FetchInput, init?: FetchInit): Promise<Response> => {\n        const url = extractUrl(input);\n        const method = init?.method || 'GET';\n\n        // Ignoruj requesty do Loggi-App (anty-pƒôtla)\n        if (url.includes('/api/logs/collect') || url.includes('/api/logs/stream')) {\n            return originalFetch!(input, init);\n        }\n\n        const start = Date.now();\n        const requestId = getRequestId();\n\n        try {\n            const response = await originalFetch!(input, init);\n\n            // Loguj tylko je≈õli SDK jest zainicjalizowane\n            if (isLoggiInitialized()) {\n                _internalLog('info', 'fetch', `${method} ${url}`, {\n                    requestUrl: url,\n                    requestMethod: method,\n                    requestStatus: response.status,\n                    requestDurationMs: Date.now() - start,\n                    requestId,\n                });\n            }\n\n            return response;\n        } catch (error) {\n            // Loguj b≈ÇƒÖd\n            if (isLoggiInitialized()) {\n                _internalLog('error', 'fetch', `${method} ${url} FAILED`, {\n                    requestUrl: url,\n                    requestMethod: method,\n                    error: error instanceof Error ? error.message : String(error),\n                    requestDurationMs: Date.now() - start,\n                    requestId,\n                });\n            }\n            throw error;\n        }\n    };\n}\n\n/**\n * Przywr√≥ƒá oryginalny fetch (do test√≥w)\n */\nexport function restoreFetch(): void {\n    if (!isCaptured || !originalFetch) return;\n\n    globalThis.fetch = originalFetch;\n    originalFetch = null;\n    isCaptured = false;\n}\n","import {\n    LoggiConfig,\n    LogLevel,\n    LogCategory,\n    LogEnvironment,\n    DEFAULT_PREFIX_MAP,\n    DEFAULT_SENSITIVE_KEYS\n} from './types';\nimport { captureConsole } from './integrations/console';\nimport { captureFetch } from './integrations/fetch';\n// UWAGA: captureUnhandled importowane dynamicznie - u≈ºywa process.on kt√≥ry nie dzia≈Ça w Edge Runtime\n\n/**\n * Globalna konfiguracja SDK\n */\nlet globalConfig: Required<LoggiConfig> | null = null;\n\n/**\n * Czy SDK zosta≈Ço zainicjalizowane\n */\nlet isInitialized = false;\n\n/**\n * Pobierz aktualnƒÖ konfiguracjƒô\n */\nexport function getConfig(): Required<LoggiConfig> {\n    if (!globalConfig) {\n        throw new Error('[LOGGI] SDK not initialized. Call initLoggi() first.');\n    }\n    return globalConfig;\n}\n\n/**\n * Sprawd≈∫ czy SDK jest zainicjalizowane\n */\nexport function isLoggiInitialized(): boolean {\n    return isInitialized;\n}\n\n/**\n * Auto-wykrywanie projectSlug\n * UWAGA: Usuniƒôto auto-detekcjƒô z package.json (niekompatybilna z Edge Runtime)\n * U≈ºyj env LOGGI_PROJECT_SLUG lub przeka≈º w config\n */\nfunction autoDetectProjectSlug(): string {\n    // Bez auto-detekcji - Edge Runtime nie obs≈Çuguje process.cwd() i require()\n    // projectSlug musi byƒá ustawiony przez env lub config\n    return 'unknown';\n}\n\n/**\n * Inicjalizacja SDK\n *\n * @example\n * // Minimalna konfiguracja (wszystko z env):\n * initLoggi();\n *\n * // Z jawnym API key:\n * initLoggi({ apiKey: 'pk_xxx' });\n *\n * // Pe≈Çna konfiguracja:\n * initLoggi({\n *   apiKey: 'pk_xxx',\n *   projectSlug: 'my-app',\n *   endpoint: 'https://loggi.example.com'\n * });\n */\nexport function initLoggi(config?: LoggiConfig): void {\n    if (isInitialized) {\n        console.warn('[LOGGI] SDK already initialized. Skipping re-initialization.');\n        return;\n    }\n\n    const cfg = config || {};\n    const isDev = process.env.NODE_ENV === 'development';\n    const environment = (cfg.environment || process.env.NODE_ENV || 'development') as LogEnvironment;\n\n    // Auto-wykrywanie projectSlug: config > env > package.json > 'unknown'\n    const projectSlug = cfg.projectSlug\n        || process.env.LOGGI_PROJECT_SLUG\n        || autoDetectProjectSlug();\n\n    // API key: config > env > brak (offline mode)\n    const apiKey = cfg.apiKey || process.env.LOGGI_API_KEY || '';\n\n    // Endpoint: config > env > default\n    // NIE dodajemy /api/logs/collect tutaj - transport.ts sam to robi\n    const endpoint = (cfg.endpoint || process.env.LOGGI_ENDPOINT || 'http://localhost:3003')\n        .replace(/\\/$/, ''); // Usu≈Ñ trailing slash\n\n    // Offline mode - gdy brak API key\n    const offlineMode = !apiKey;\n\n    globalConfig = {\n        apiKey,\n        endpoint,\n        projectSlug,\n        environment,\n        captureConsole: cfg.captureConsole ?? true,\n        captureFetch: cfg.captureFetch ?? true,\n        captureUnhandled: cfg.captureUnhandled ?? true,\n        batchSize: cfg.batchSize ?? 10,\n        batchTimeoutMs: cfg.batchTimeoutMs ?? 5000,\n        debug: cfg.debug ?? isDev,\n        consoleInDev: cfg.consoleInDev ?? true,\n        minLevel: cfg.minLevel ?? (isDev ? 'log' : 'info'),\n        sensitiveKeys: cfg.sensitiveKeys ?? DEFAULT_SENSITIVE_KEYS,\n        prefixMap: { ...DEFAULT_PREFIX_MAP, ...cfg.prefixMap },\n        offlineMode,\n    };\n\n    // Auto-inicjalizacja integracji\n    if (globalConfig.captureConsole) {\n        captureConsole();\n    }\n    if (globalConfig.captureFetch) {\n        captureFetch();\n    }\n    if (globalConfig.captureUnhandled) {\n        // Dynamic import - captureUnhandled u≈ºywa process.on kt√≥ry nie dzia≈Ça w Edge Runtime\n        import('./integrations/unhandled').then(({ captureUnhandled }) => {\n            captureUnhandled();\n        }).catch(() => {\n            // Edge Runtime - ignoruj b≈ÇƒÖd\n        });\n    }\n\n    isInitialized = true;\n\n    // Logowanie inicjalizacji\n    if (offlineMode) {\n        console.log('[LOGGI] SDK initialized in OFFLINE mode (no API key)', {\n            projectSlug: globalConfig.projectSlug,\n            environment: globalConfig.environment,\n        });\n    } else {\n        if (globalConfig.debug) {\n            console.log('[LOGGI] SDK initialized', {\n                projectSlug: globalConfig.projectSlug,\n                environment: globalConfig.environment,\n                endpoint: globalConfig.endpoint,\n                captureConsole: globalConfig.captureConsole,\n                captureFetch: globalConfig.captureFetch,\n                captureUnhandled: globalConfig.captureUnhandled,\n            });\n        }\n\n        // Inicjalizuj transport z retry logic (w tle, nie blokuje)\n        // U≈ºywamy dynamic import aby uniknƒÖƒá cyklicznej zale≈ºno≈õci\n        import('./transport').then(({ initTransport }) => {\n            initTransport().catch(() => {\n                // B≈Çƒôdy obs≈Çugiwane wewnƒôtrznie przez initTransport\n            });\n        });\n    }\n}\n\n/**\n * Reset SDK (g≈Ç√≥wnie do test√≥w)\n */\nexport function resetLoggi(): void {\n    globalConfig = null;\n    isInitialized = false;\n}\n","/**\n * Eksporty specyficzne dla Next.js\n */\nexport { runWithRequestId, getRequestId } from './request-context';\nexport { withLogging, createLoggingMiddleware } from './middleware';\n","import { NextRequest, NextResponse } from 'next/server';\nimport { runWithRequestId, generateRequestId } from './request-context';\nimport { isLoggiInitialized } from '../config';\nimport { _internalLog } from '../logger';\n\ntype NextRouteHandler = (\n    request: NextRequest,\n    context?: { params?: Record<string, string | string[]> }\n) => Promise<NextResponse> | NextResponse;\n\n/**\n * Higher-Order Function opakowujƒÖca route handlery Next.js\n * Dodaje requestId do kontekstu i loguje request/response\n */\nexport function withLogging(handler: NextRouteHandler): NextRouteHandler {\n    return async (request: NextRequest, context?: { params?: Record<string, string | string[]> }) => {\n        const start = Date.now();\n        const method = request.method;\n        const url = request.nextUrl.pathname;\n        const requestId = generateRequestId();\n\n        return runWithRequestId(requestId, async () => {\n\n            try {\n                const response = await handler(request, context);\n\n                // Loguj sukces\n                if (isLoggiInitialized()) {\n                    _internalLog('info', 'api', `${method} ${url}`, {\n                        requestUrl: url,\n                        requestMethod: method,\n                        requestStatus: response.status,\n                        requestDurationMs: Date.now() - start,\n                        requestId,\n                    });\n                }\n\n                // Dodaj requestId do response headers (przydatne do debugowania)\n                if (requestId) {\n                    response.headers.set('X-Request-Id', requestId);\n                }\n\n                return response;\n            } catch (error) {\n                // Loguj b≈ÇƒÖd\n                if (isLoggiInitialized()) {\n                    _internalLog('error', 'api', `${method} ${url} FAILED`, {\n                        requestUrl: url,\n                        requestMethod: method,\n                        error: error instanceof Error ? error.message : String(error),\n                        stack: error instanceof Error ? error.stack : undefined,\n                        requestDurationMs: Date.now() - start,\n                        requestId,\n                    });\n                }\n                throw error;\n            }\n        });\n    };\n}\n\n/**\n * Middleware do logowania wszystkich request√≥w (dla next.config.js middleware)\n * U≈ºycie: export default loggingMiddleware;\n */\nexport function createLoggingMiddleware() {\n    return async (request: NextRequest) => {\n        const start = Date.now();\n        const method = request.method;\n        const url = request.nextUrl.pathname;\n\n        // Generuj requestId\n        const requestId = crypto.randomUUID();\n\n        // Loguj request\n        if (isLoggiInitialized()) {\n            _internalLog('log', 'middleware', `${method} ${url}`, {\n                requestUrl: url,\n                requestMethod: method,\n                requestId,\n                userAgent: request.headers.get('user-agent') || undefined,\n            });\n        }\n\n        // Kontynuuj do nastƒôpnego middleware/route\n        const response = NextResponse.next();\n\n        // Dodaj requestId do headers\n        response.headers.set('X-Request-Id', requestId);\n\n        return response;\n    };\n}\n"],"mappings":"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","names":[]}